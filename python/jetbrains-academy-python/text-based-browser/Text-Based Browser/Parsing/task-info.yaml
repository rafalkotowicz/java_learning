type: edu
custom_name: stage5
files:
- name: tests.py
  visible: false
  text: |
    from hstest.stage_test import StageTest
    from hstest.test_case import TestCase
    from hstest.check_result import CheckResult

    import os
    import shutil

    import sys
    if sys.platform.startswith("win"):
        import _locale
        # pylint: disable=protected-access
        _locale._getdefaultlocale = (lambda *args: ['en_US', 'utf8'])

    CheckResult.correct = lambda: CheckResult(True, '')
    CheckResult.wrong = lambda feedback: CheckResult(False, feedback)


    class TextBasedBrowserTest(StageTest):

        def generate(self):

            dir_for_files = os.path.join(os.curdir, 'tb_tabs')
            return [
                TestCase(
                    stdin='3.python-requests.org\nexit',
                    attach='requests',
                    args=[dir_for_files]
                ),
                TestCase(
                    stdin='nytimes.com\nnytimes\nexit',
                    attach='The New York Times',
                    args=[dir_for_files]
                ),
                TestCase(
                    stdin='nytimescom\nexit',
                    args=[dir_for_files]
                ),
                TestCase(
                    stdin='bloombergcom\nexit',
                    args=[dir_for_files]
                ),
            ]

        def _check_files(self, path_for_tabs: str, right_word: str) -> int:
            """
            Helper which checks that browser saves visited url in files and
            provides access to them.

            :param path_for_tabs: directory which must contain saved tabs
            :param right_word: Word-marker which must be in right tab
            :return: True, if right_words is present in saved tab
            """

            path, dirs, filenames = next(os.walk(path_for_tabs))

            for file in filenames:

                with open(os.path.join(path_for_tabs, file), 'r', encoding='utf-8') as tab:
                    try:
                        content = tab.read()
                    except UnicodeDecodeError:
                        return -1

                    if '</p>' not in content and '</script>' not in content:
                        if '</div>' not in content and right_word in content:
                            return 1

            return 0

        def check(self, reply, attach):

            # Incorrect URL
            if attach is None:
                if '<p>' in reply:
                    return CheckResult.wrong('You haven\'t checked whether URL was correct')
                else:
                    return CheckResult.correct()

            # Correct URL
            if isinstance(attach, str):
                right_word = attach

                path_for_tabs = os.path.join(os.curdir, 'tb_tabs')

                if not os.path.isdir(path_for_tabs):
                    return CheckResult.wrong("There are no directory for tabs")

                check_files_result = self._check_files(path_for_tabs, right_word)
                if not check_files_result:
                    return CheckResult.wrong('There are no correct saved tabs')
                elif check_files_result == -1:
                    return CheckResult.wrong('An error occurred while reading your saved tab. '
                                             'Perhaps you used the wrong encoding?')

                try:
                    shutil.rmtree(path_for_tabs)
                except PermissionError:
                    return CheckResult.wrong("Impossible to remove the directory for tabs. Perhaps you haven't closed some file?")

                if '</p>' not in reply and '</div>' not in reply:
                    if right_word in reply:
                        return CheckResult.correct()

                return CheckResult.wrong('You haven\'t parsed result of request')


    TextBasedBrowserTest('browser.browser').run_tests()
  learner_created: false
- name: browser/browser.py
  visible: true
  text: |
    import os
    from collections import deque
    from os import rmdir, mkdir, path
    from urllib.parse import urlparse

    import requests
    import sys

    # INIT
    print("[DEBUG] Initialization STARTED")

    expected_noof_arguments = 1
    provided_args = f"You provided {len(sys.argv) - 1} arguments"
    expected_args = f"Expected exactly {expected_noof_arguments} argument"

    if len(sys.argv) - 1 < expected_noof_arguments:
        print(f"[ERROR] Too few arguments passed to script. {provided_args}. {expected_args}.")
        sys.exit(-1)
    elif len(sys.argv) - 1 > expected_noof_arguments:
        print(f"[ERROR] Too many arguments passed to script. {provided_args}. {expected_args}.")
        sys.exit(-1)

    workdir = sys.argv[1]
    if os.path.exists(workdir):
        for root, dirs, files in os.walk(workdir, topdown=False):
            for name in files:
                os.remove(os.path.join(root, name))
        for name in dirs:
            os.rmdir(os.path.join(root, name))

        rmdir(workdir)
        print(f"[DEBUG] Directory found and removed: {workdir}")

    mkdir(workdir)
    print(f"[DEBUG] Directory created: {workdir}")

    print("[DEBUG] Initialization DONE")


    # UTILS
    def is_url(maybe_url):
        parsed_url = urlparse(maybe_url)
        if str(parsed_url.path).__contains__("."):
            return True
        else:
            return False


    def read_file(file_name):
        file_path = path.join(workdir, file_name)
        if path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as file_to_read:
                print(file_to_read.read())
                history.append(file_name)


    def write_file(file_name, content):
        file_path = path.join(workdir, file_name)
        with open(file_path, 'w', encoding='utf-8') as file_to_write:
            file_to_write.write(content)


    def add_https_protocol(url: str):
        if not url.startswith("https://"):
            return "https://" + url


    def remove_https_protocol(url: str):
        return url.replace("https://", "")


    def strip_file_name(url: str):
        file_name = remove_https_protocol(url)
        return file_name[0:file_name.find(".")]


    def call_the_internetz(url: str):
        response = requests.get(add_https_protocol(url))
        file_name = strip_file_name(url)
        write_file(file_name, response.text)
        read_file(file_name)


    # MAIN
    history = deque()

    while True:
        command = input("Provide valid URL or type 'exit' to leave the program\n")

        if command == "exit":
            break

        if command == "back":
            print(f"History len: {len(history)}")
            if len(history) == 0:
                continue
            else:
                history.pop()
                command = history.pop()

        if is_url(command):
            call_the_internetz(command)
        else:
            read_file(command)
  learner_created: true
feedback_link: https://hyperskill.org/projects/79/stages/440/implement
status: Unchecked
record: -1
